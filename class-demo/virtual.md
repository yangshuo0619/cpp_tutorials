# 虚函数
在类的成员函数前加virtual关键字的函数。一般把虚函数定义在public区，方便在主函数调用.  
如果一个类有一个虚函数，则该类就有一个虚函数表。系统会为当前类分配一个虚函数表，里面存放的虚函数指针。这样会增加类的存储空间。  
所有该类的对象共享这个虚函数。只有一个虚函数表。子类的虚函数表中，子类的虚函数覆盖了父类的虚函数的情况：当子类将父类的虚函数override时，就覆盖了父类的虚函数。override?重写？

# 虚析构函数
**当一个类有子类时，该类的析构函数必须是虚函数**，原因：如果是非虚的析构函数，会有资源释放不完全的情况!!!  
c++语言标准关于这个问题的阐述非常清楚：当通过基类的指针去删除派生类的对象 ，而基类又没有虚析构函数时，结果将是不可确定的。这意味着编译器生成的 代码将会做任何它喜欢的事：重新格式化你的硬盘，给你的老板发电子邮件，把你的程序源代码传真给你的对手，无论什么事都可能发生。（实际运行时经常发生的 是，派生类的析构函数永远不会被调用。）  
所以对于虚析构函数，他的作用是：！！！防止内存泄漏。！！！！！！！（用于父类指针指向子类对象的时候，非虚的析构函数会造成只调用基类的析构函数而不调用子类的析构函数，使基类被销毁，而子类没有，造成内存泄漏）。


```c++
class Father;
class Son : public class Father;
Father* pointer = new Son;
```
在上述条件下，可以实现多态,当释放时
```c++
delete pointer;
```

在这个时候，如果，father类和son类的析构是虚函数才能够正确释放。  
析构函数的工作方式是：最底层的派生类（most derived class）的析构函数最先被调用，然后调用每一个基类的析构函数。（构造函数正好相反，先构造基类的，然后执行派生类的构造函数。）  
具体实例：定义一个基类的指针p，在delete p时，  
* 如果基类的析构函数是虚函数，这时会看**p所赋值的对象**，
    * 如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；
    * 如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。

* 但是如果基类的析构函数不是虚函数，
    * 在delete p时，调用析构函数时，只会看**指针的数据类型** ，而不会去看赋值的对象，这样就会造成内存泄露。只调用基类的析构，而不调用子类的析构。

    所以：在C++中，当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，则结果是未定义的。运行时比较有代表性的后果是对象的派生部分不会被销毁。然而，基类部分很可能已被销毁，这就导致了一个古怪的“部分析构”对象，这是一个泄漏资源。排除这个问题非常简单：给基类一个虚析构函数。于是，删除一个派生类对象的时候就有了你所期望的正确行为。将销毁整个对象，包括全部的派生类部分。另外：纯虚的析构函数可以不用实现！！！！


## 虚函数表

       一般如果不做基类的类的析构函数一般不声明为虚函数，因为虚函数的实现要求对象携带额外的信息，这些信息用于在运行时确定该对象应该调用哪一个虚函数.  
   典型情况下，这一信息具有一种被称为 vptr（virtual table pointer，虚函数表指针）的指针的形式。vptr 指向一个被称为 vtbl（virtual table，虚函数表）的函数指针数组，    每一个包含虚函数的类都关联到 vtbl。当一个对象调用了虚函数，实际的被调用函数通过下面的步骤确定：找到对象的 vptr 指向的 vtbl，然后在 vtbl 中寻找合适的函数指针。这样子会使类所占用的内存增加。  
   虚函数表vtbl，每一个拥有虚成员函数的类都有一个指向虚函数表的指针。对象通过虚函数表里存储的虚函数地址来调用虚函数。

另外：**构造函数不能是虚函数**！！！
	构造函数不能是虚函数呢？这里你需要知道一个概念，那就是虚函数表vtbl，每一个拥有虚成员函数的类都有一个指向虚函数表的指针。对象通过虚函数表里存储的虚函数地址来调用虚函数。  
      虚函数表指针是什么时候初始化的呢？当然是构造函数。当我们通过new来创建一个对象的时候，第一步是申请需要的内存，第二步就是调用构造函数。试想，如果构造函数是虚函数，那必然需要通过vtbl来找到虚构造函数的入口地址，显然，我们申请的内存还没有做任何初始化，不可能有vtbl的。因此，构造函数不能是虚函数。

 
### 虚函数实现机制

  虚函数主要是实现了多态的机制。关于多态，就是用父类类型的指针指向子类的实例。通过父类的指针调用子类的成员函数。这样可以让父类的指针有多种形态。这是一种泛型技术。泛型技术，就是试图使用不变的代码来实现可变的算法。虚函数（virtual function）是通过一张虚函数表（virtual table）来实现。v-table。表中是一个类的虚函数的地址表，这张表 解决了继承，覆盖的问题。当用父类的指针来操作一个子类的时候，虚函数表就像地图 。指明实际所应该调用的数.C++的标准规格说明书中说到，编译器必须要保证虚函数表的指针存在于对象实例中最前面的位置。（为了保证正确读取到虚函数的偏移量）。意味着我们通过 对象实例的地址 得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。


虚函数主要是实现了多态的机制。关于多态，就是用
```c++
class Base {

public:

virtual void f() { cout << "Base::f" << endl; }

virtual void g() { cout << "Base::g" << endl; }

virtual void h() { cout << "Base::h" << endl; }

};
```

我们可以通过Base的实例来得到虚函数表。

```c++
typedef void(*Fun)(void);
Base b;
Fun pFUN = NULL;
cout << "虚函数表地址： ”<< (int*)(&b) << endl;
cout << "虚函数表-第一个函数地址: " << (int*)*(int*)(&b) << endl;

pFun = (Fun)* ( (int*)*(int*)(&b) );
pFun();
```

我们可以看到，我们可以通过强行把&b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：

```c++
(Fun)*( (int*)*(int*)(&b) + 0); // Base::f()

(Fun)*( (int*)*(int*)(&b) + 1); // Base::g()

(Fun)*( (int*)*(int*)(&b) + 2); // Base::h()
```

虚函数表举例：  
父类实例：&b ： | Base::f() | Base::g() | Base::h() |  . |
最后的点是虚函数表的结束结点，类似字符串的结束符“/0”一样。标志了虚函数表的结束。结束标志在不同编译器下是不同的。  
* 一般继承：
```c++
class Derive : public Base;
```
子类实例：  
* 如果是无虚函数覆盖：  
    Base : f(); g(); h();  
    Derive: f1(); g(); h();

子类没有重载父类的任何函数。那么在派生类的实例中，其虚函数表：
&d:  |  Base::f() | Base::g() | Base::h() | Derive::f1() | Derive::g1() | Derive::h1() |  .  |
1. 虚函数按照其声明顺序放于表中。
2. 父类的虚函数在子类的虚函数前面

* 如果是有虚函数覆盖：  
    Base : f(); g(); h();  
    Derive: f(); g(); h();  
    那么，对于派生类的实例，其虚函数表会是下面的一个样子：  
    &d:  |  Derive::f() | Base::g() | Base::h() |  .  |
1. 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
2. 没有被覆盖的函数依旧。

对于
```c++
Base *b = new Derive();
b->f();
```
b所指的内存中的虚函数表的f()位置已经被Derive::f()函数地址所取代。在实际调用时，是Derived::f()被调用。这就实现了多态。

 
* 多重继承：
父类：
```c++
Base1 : f(); g(); h();
Base2 : f(); g(); h();
Base3 : f(); g(); h();
```

* 无虚函数覆盖：
子类：Derive: f1(); g1();  
子类实例中的虚函数表，是下面这个样子：  
&d:  
虚函数表Base1:  | Base1::f() | Base1::g() | Base1::h() |  Derive::f1() | Derive::g1() |  .   |  
虚函数表Base2:  | Base2::f() | Base2::g() | Base2::h() |  .   |  
虚函数表Base3:  | Base3::f() | Base3::g() | Base3::h() |  .   |
1. 每个父类都有自己的虚表。
2. 子类的成员函数被放到第一个父类的表中。

* 有虚函数覆盖：
子类：Derive: f(); g1();  
&d:  
虚函数表Base1: | Derive::f() | Base1::g() | Base1::h() |  Derive::g1() |  .   |
虚函数表Base2:  | Derive::f() | Base2::g() | Base2::h() |  .   |
虚函数表Base3:  | Derive::f() | Base3::g() | Base3::h() |  .   |  

三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：
```c++
Derive d;

Base1 *b1 = &d;

Base2 *b2 = &d;

Base3 *b3 = &d;

b1->f(); //Derive::f()

b2->f(); //Derive::f()

b3->f(); //Derive::f()

b1->g(); //Base1::g()

b2->g(); //Base2::g()

b3->g(); //Base3::g()
```



* base knowlege:
纯虚函数：形式为virtual void fun() = 0;   
纯虚函数不需要实现，原因是因为不会被调用。  

抽象基类：至少有一个 纯虚函数 的类；  
抽象基类不能产生该类的对象，即不能实例化，但可以有该类的指针或引用。  
在子类中必须将父类的纯虚函数实现，否则该子类也是抽象基类。

### 虚函数和纯虚函数的区别
虚函数是“推迟联编”，“动态联编”的，一个类函数的调用并不是在编译时刻被确定，而是在运行时刻被确定。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数。所以被成为虚函数。**虚函数只能借助于指针或者引用来达到多态的效果**。

1. 为了使用多态特性，所以在基类中定义虚拟函数。
2. 很多情况下，基类本身生成对象是不合情理的。eg。动物可以派生出老虎，狮子，但是动物本身生成对象就不合理。

为了解决上述问题，引入纯虚函数，virtual ReturnType Function() = 0; 编译器要求在派生类中必须对其重写以实现多态。此时类为抽象类，不能生成对象，只能创建他的派生类实例。

    定义纯虚函数的目的在于使派生类仅仅只是继承函数的接口，用于规范派生类的行为，即接口。

纯虚函数是没有定义的，是用于规范派生类的接口。而虚函数必须要有实现。
虚函数是C++中用于实现多态的机制，核心就是通过基类访问派生类定义的函数。

